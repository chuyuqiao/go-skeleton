// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kratos-demo/vendor/github.com/bilibili/kratos/pkg/net/trace/proto/span.proto

package protogen

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	duration "github.com/golang/protobuf/ptypes/duration"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Tag_Kind int32

const (
	Tag_STRING Tag_Kind = 0
	Tag_INT    Tag_Kind = 1
	Tag_BOOL   Tag_Kind = 2
	Tag_FLOAT  Tag_Kind = 3
)

var Tag_Kind_name = map[int32]string{
	0: "STRING",
	1: "INT",
	2: "BOOL",
	3: "FLOAT",
}

var Tag_Kind_value = map[string]int32{
	"STRING": 0,
	"INT":    1,
	"BOOL":   2,
	"FLOAT":  3,
}

func (x Tag_Kind) String() string {
	return proto.EnumName(Tag_Kind_name, int32(x))
}

func (Tag_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9c40abaa160663e9, []int{0, 0}
}

// Deprecated: Kind no long use
type Log_Kind int32

const (
	Log_STRING Log_Kind = 0
	Log_INT    Log_Kind = 1
	Log_BOOL   Log_Kind = 2
	Log_FLOAT  Log_Kind = 3
)

var Log_Kind_name = map[int32]string{
	0: "STRING",
	1: "INT",
	2: "BOOL",
	3: "FLOAT",
}

var Log_Kind_value = map[string]int32{
	"STRING": 0,
	"INT":    1,
	"BOOL":   2,
	"FLOAT":  3,
}

func (x Log_Kind) String() string {
	return proto.EnumName(Log_Kind_name, int32(x))
}

func (Log_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9c40abaa160663e9, []int{2, 0}
}

type SpanRef_RefType int32

const (
	SpanRef_CHILD_OF     SpanRef_RefType = 0
	SpanRef_FOLLOWS_FROM SpanRef_RefType = 1
)

var SpanRef_RefType_name = map[int32]string{
	0: "CHILD_OF",
	1: "FOLLOWS_FROM",
}

var SpanRef_RefType_value = map[string]int32{
	"CHILD_OF":     0,
	"FOLLOWS_FROM": 1,
}

func (x SpanRef_RefType) String() string {
	return proto.EnumName(SpanRef_RefType_name, int32(x))
}

func (SpanRef_RefType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9c40abaa160663e9, []int{3, 0}
}

type Tag struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Kind                 Tag_Kind `protobuf:"varint,2,opt,name=kind,proto3,enum=dapper.trace.Tag_Kind" json:"kind,omitempty"`
	Value                []byte   `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tag) Reset()         { *m = Tag{} }
func (m *Tag) String() string { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()    {}
func (*Tag) Descriptor() ([]byte, []int) {
	return fileDescriptor_9c40abaa160663e9, []int{0}
}
func (m *Tag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tag.Merge(m, src)
}
func (m *Tag) XXX_Size() int {
	return m.Size()
}
func (m *Tag) XXX_DiscardUnknown() {
	xxx_messageInfo_Tag.DiscardUnknown(m)
}

var xxx_messageInfo_Tag proto.InternalMessageInfo

func (m *Tag) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Tag) GetKind() Tag_Kind {
	if m != nil {
		return m.Kind
	}
	return Tag_STRING
}

func (m *Tag) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type Field struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                []byte   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Field) Reset()         { *m = Field{} }
func (m *Field) String() string { return proto.CompactTextString(m) }
func (*Field) ProtoMessage()    {}
func (*Field) Descriptor() ([]byte, []int) {
	return fileDescriptor_9c40abaa160663e9, []int{1}
}
func (m *Field) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Field) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Field.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Field) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Field.Merge(m, src)
}
func (m *Field) XXX_Size() int {
	return m.Size()
}
func (m *Field) XXX_DiscardUnknown() {
	xxx_messageInfo_Field.DiscardUnknown(m)
}

var xxx_messageInfo_Field proto.InternalMessageInfo

func (m *Field) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Field) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type Log struct {
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Deprecated: Kind no long use
	Kind Log_Kind `protobuf:"varint,2,opt,name=kind,proto3,enum=dapper.trace.Log_Kind" json:"kind,omitempty"`
	// Deprecated: Value no long use
	Value                []byte   `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Timestamp            int64    `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Fields               []*Field `protobuf:"bytes,5,rep,name=fields,proto3" json:"fields,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Log) Reset()         { *m = Log{} }
func (m *Log) String() string { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()    {}
func (*Log) Descriptor() ([]byte, []int) {
	return fileDescriptor_9c40abaa160663e9, []int{2}
}
func (m *Log) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Log) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Log.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Log) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Log.Merge(m, src)
}
func (m *Log) XXX_Size() int {
	return m.Size()
}
func (m *Log) XXX_DiscardUnknown() {
	xxx_messageInfo_Log.DiscardUnknown(m)
}

var xxx_messageInfo_Log proto.InternalMessageInfo

func (m *Log) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Log) GetKind() Log_Kind {
	if m != nil {
		return m.Kind
	}
	return Log_STRING
}

func (m *Log) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Log) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Log) GetFields() []*Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

// SpanRef describes causal relationship of the current span to another span (e.g. 'child-of')
type SpanRef struct {
	RefType              SpanRef_RefType `protobuf:"varint,1,opt,name=ref_type,json=refType,proto3,enum=dapper.trace.SpanRef_RefType" json:"ref_type,omitempty"`
	TraceId              uint64          `protobuf:"varint,2,opt,name=trace_id,json=traceId,proto3" json:"trace_id,omitempty"`
	SpanId               uint64          `protobuf:"varint,3,opt,name=span_id,json=spanId,proto3" json:"span_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SpanRef) Reset()         { *m = SpanRef{} }
func (m *SpanRef) String() string { return proto.CompactTextString(m) }
func (*SpanRef) ProtoMessage()    {}
func (*SpanRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_9c40abaa160663e9, []int{3}
}
func (m *SpanRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpanRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpanRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanRef.Merge(m, src)
}
func (m *SpanRef) XXX_Size() int {
	return m.Size()
}
func (m *SpanRef) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanRef.DiscardUnknown(m)
}

var xxx_messageInfo_SpanRef proto.InternalMessageInfo

func (m *SpanRef) GetRefType() SpanRef_RefType {
	if m != nil {
		return m.RefType
	}
	return SpanRef_CHILD_OF
}

func (m *SpanRef) GetTraceId() uint64 {
	if m != nil {
		return m.TraceId
	}
	return 0
}

func (m *SpanRef) GetSpanId() uint64 {
	if m != nil {
		return m.SpanId
	}
	return 0
}

// Span represents a named unit of work performed by a service.
type Span struct {
	Version       int32  `protobuf:"varint,99,opt,name=version,proto3" json:"version,omitempty"`
	ServiceName   string `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	OperationName string `protobuf:"bytes,2,opt,name=operation_name,json=operationName,proto3" json:"operation_name,omitempty"`
	// Deprecated: caller no long required
	Caller   string `protobuf:"bytes,3,opt,name=caller,proto3" json:"caller,omitempty"`
	TraceId  uint64 `protobuf:"varint,4,opt,name=trace_id,json=traceId,proto3" json:"trace_id,omitempty"`
	SpanId   uint64 `protobuf:"varint,5,opt,name=span_id,json=spanId,proto3" json:"span_id,omitempty"`
	ParentId uint64 `protobuf:"varint,6,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty"`
	// Deprecated: level no long required
	Level int32 `protobuf:"varint,7,opt,name=level,proto3" json:"level,omitempty"`
	// Deprecated: use start_time instead instead of start_at
	StartAt int64 `protobuf:"varint,8,opt,name=start_at,json=startAt,proto3" json:"start_at,omitempty"`
	// Deprecated: use duration instead instead of finish_at
	FinishAt             int64                `protobuf:"varint,9,opt,name=finish_at,json=finishAt,proto3" json:"finish_at,omitempty"`
	SamplingProbability  float32              `protobuf:"fixed32,10,opt,name=sampling_probability,json=samplingProbability,proto3" json:"sampling_probability,omitempty"`
	Env                  string               `protobuf:"bytes,19,opt,name=env,proto3" json:"env,omitempty"`
	StartTime            *timestamp.Timestamp `protobuf:"bytes,20,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	Duration             *duration.Duration   `protobuf:"bytes,21,opt,name=duration,proto3" json:"duration,omitempty"`
	References           []*SpanRef           `protobuf:"bytes,22,rep,name=references,proto3" json:"references,omitempty"`
	Tags                 []*Tag               `protobuf:"bytes,11,rep,name=tags,proto3" json:"tags,omitempty"`
	Logs                 []*Log               `protobuf:"bytes,12,rep,name=logs,proto3" json:"logs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Span) Reset()         { *m = Span{} }
func (m *Span) String() string { return proto.CompactTextString(m) }
func (*Span) ProtoMessage()    {}
func (*Span) Descriptor() ([]byte, []int) {
	return fileDescriptor_9c40abaa160663e9, []int{4}
}
func (m *Span) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Span) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Span.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Span) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Span.Merge(m, src)
}
func (m *Span) XXX_Size() int {
	return m.Size()
}
func (m *Span) XXX_DiscardUnknown() {
	xxx_messageInfo_Span.DiscardUnknown(m)
}

var xxx_messageInfo_Span proto.InternalMessageInfo

func (m *Span) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Span) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *Span) GetOperationName() string {
	if m != nil {
		return m.OperationName
	}
	return ""
}

func (m *Span) GetCaller() string {
	if m != nil {
		return m.Caller
	}
	return ""
}

func (m *Span) GetTraceId() uint64 {
	if m != nil {
		return m.TraceId
	}
	return 0
}

func (m *Span) GetSpanId() uint64 {
	if m != nil {
		return m.SpanId
	}
	return 0
}

func (m *Span) GetParentId() uint64 {
	if m != nil {
		return m.ParentId
	}
	return 0
}

func (m *Span) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Span) GetStartAt() int64 {
	if m != nil {
		return m.StartAt
	}
	return 0
}

func (m *Span) GetFinishAt() int64 {
	if m != nil {
		return m.FinishAt
	}
	return 0
}

func (m *Span) GetSamplingProbability() float32 {
	if m != nil {
		return m.SamplingProbability
	}
	return 0
}

func (m *Span) GetEnv() string {
	if m != nil {
		return m.Env
	}
	return ""
}

func (m *Span) GetStartTime() *timestamp.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *Span) GetDuration() *duration.Duration {
	if m != nil {
		return m.Duration
	}
	return nil
}

func (m *Span) GetReferences() []*SpanRef {
	if m != nil {
		return m.References
	}
	return nil
}

func (m *Span) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Span) GetLogs() []*Log {
	if m != nil {
		return m.Logs
	}
	return nil
}

func init() {
	proto.RegisterEnum("dapper.trace.Tag_Kind", Tag_Kind_name, Tag_Kind_value)
	proto.RegisterEnum("dapper.trace.Log_Kind", Log_Kind_name, Log_Kind_value)
	proto.RegisterEnum("dapper.trace.SpanRef_RefType", SpanRef_RefType_name, SpanRef_RefType_value)
	proto.RegisterType((*Tag)(nil), "dapper.trace.Tag")
	proto.RegisterType((*Field)(nil), "dapper.trace.Field")
	proto.RegisterType((*Log)(nil), "dapper.trace.Log")
	proto.RegisterType((*SpanRef)(nil), "dapper.trace.SpanRef")
	proto.RegisterType((*Span)(nil), "dapper.trace.Span")
}

func init() {
	proto.RegisterFile("kratos-demo/vendor/github.com/bilibili/kratos/pkg/net/trace/proto/span.proto", fileDescriptor_9c40abaa160663e9)
}

var fileDescriptor_9c40abaa160663e9 = []byte{
	// 725 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0xd1, 0x8e, 0xe3, 0x34,
	0x14, 0x86, 0xd7, 0x4d, 0xda, 0xa4, 0x67, 0xca, 0x28, 0x78, 0x66, 0x8b, 0x77, 0x80, 0x12, 0x2a,
	0xad, 0x14, 0x40, 0x24, 0x50, 0xb4, 0x12, 0x5c, 0xce, 0xb2, 0x2a, 0x54, 0x84, 0x29, 0xf2, 0x54,
	0x42, 0xe2, 0xa6, 0x72, 0x1b, 0x37, 0x1b, 0x35, 0x8d, 0x23, 0xc7, 0xad, 0xd4, 0x67, 0xe0, 0x2d,
	0x78, 0x1a, 0x2e, 0xb9, 0xe2, 0x0e, 0x09, 0xcd, 0x93, 0x20, 0x3b, 0x69, 0xb7, 0xc3, 0x0c, 0x42,
	0x70, 0x51, 0xc9, 0xe7, 0xfc, 0x9f, 0x7d, 0xce, 0x71, 0x7f, 0x07, 0xe2, 0xb5, 0x64, 0x4a, 0x54,
	0x9f, 0x26, 0x7c, 0x23, 0xa2, 0x1d, 0x2f, 0x12, 0x21, 0xa3, 0x34, 0x53, 0xaf, 0xb7, 0x8b, 0x70,
	0x29, 0x36, 0xd1, 0x22, 0xcb, 0x33, 0xfd, 0x8b, 0x6a, 0x2c, 0x2a, 0xd7, 0x69, 0x54, 0x70, 0x15,
	0x29, 0xc9, 0x96, 0x3c, 0x2a, 0xa5, 0x50, 0x22, 0xaa, 0x4a, 0x56, 0x84, 0x66, 0x89, 0x7b, 0x09,
	0x2b, 0x4b, 0x2e, 0x43, 0x23, 0x5f, 0x7d, 0x90, 0x0a, 0x91, 0xe6, 0x0d, 0xb6, 0xd8, 0xae, 0x22,
	0x95, 0x6d, 0x78, 0xa5, 0xd8, 0xa6, 0xac, 0xf1, 0xab, 0xc1, 0xdf, 0x81, 0x64, 0x2b, 0x99, 0xca,
	0x44, 0x73, 0xdc, 0xf0, 0x67, 0x04, 0xd6, 0x8c, 0xa5, 0xd8, 0x03, 0x6b, 0xcd, 0xf7, 0x04, 0xf9,
	0x28, 0xe8, 0x52, 0xbd, 0xc4, 0x1f, 0x83, 0xbd, 0xce, 0x8a, 0x84, 0xb4, 0x7c, 0x14, 0x9c, 0x8f,
	0xfa, 0xe1, 0x69, 0xdd, 0x70, 0xc6, 0xd2, 0xf0, 0xbb, 0xac, 0x48, 0xa8, 0x61, 0xf0, 0x25, 0xb4,
	0x77, 0x2c, 0xdf, 0x72, 0x62, 0xf9, 0x28, 0xe8, 0xd1, 0x3a, 0x18, 0x7e, 0x06, 0xb6, 0x66, 0x30,
	0x40, 0xe7, 0x76, 0x46, 0x27, 0x37, 0xdf, 0x78, 0x4f, 0xb0, 0x03, 0xd6, 0xe4, 0x66, 0xe6, 0x21,
	0xec, 0x82, 0xfd, 0x72, 0x3a, 0x8d, 0xbd, 0x16, 0xee, 0x42, 0x7b, 0x1c, 0x4f, 0xaf, 0x67, 0x9e,
	0x35, 0x8c, 0xa0, 0x3d, 0xce, 0x78, 0x9e, 0x3c, 0xd2, 0xce, 0xb1, 0x44, 0xeb, 0xb4, 0xc4, 0xef,
	0x08, 0xac, 0x58, 0xfc, 0xe7, 0xf6, 0x63, 0xf1, 0xef, 0xed, 0xe3, 0xf7, 0xa0, 0x7b, 0xbc, 0x4d,
	0x62, 0xfb, 0x28, 0xb0, 0xe8, 0x9b, 0x04, 0xfe, 0x04, 0x3a, 0x2b, 0xdd, 0x6a, 0x45, 0xda, 0xbe,
	0x15, 0x9c, 0x8d, 0x2e, 0xee, 0x57, 0x30, 0x63, 0xd0, 0x06, 0xf9, 0x1f, 0x37, 0xf1, 0x0b, 0x02,
	0xe7, 0xb6, 0x64, 0x05, 0xe5, 0x2b, 0xfc, 0x25, 0xb8, 0x92, 0xaf, 0xe6, 0x6a, 0x5f, 0x72, 0x33,
	0xe1, 0xf9, 0xe8, 0xfd, 0xfb, 0xc5, 0x1a, 0x30, 0xa4, 0x7c, 0x35, 0xdb, 0x97, 0x9c, 0x3a, 0xb2,
	0x5e, 0xe0, 0x67, 0xe0, 0x1a, 0x62, 0x9e, 0xd5, 0x17, 0x61, 0x53, 0xc7, 0xc4, 0x93, 0x04, 0xbf,
	0x03, 0x8e, 0x76, 0x95, 0x56, 0x2c, 0xa3, 0x74, 0x74, 0x38, 0x49, 0x86, 0x1f, 0x81, 0xd3, 0x9c,
	0x83, 0x7b, 0xe0, 0x7e, 0xfd, 0xed, 0x24, 0x7e, 0x35, 0x9f, 0x8e, 0xbd, 0x27, 0xd8, 0x83, 0xde,
	0x78, 0x1a, 0xc7, 0xd3, 0x1f, 0x6f, 0xe7, 0x63, 0x3a, 0xfd, 0xde, 0x43, 0xc3, 0x3f, 0x6c, 0xb0,
	0x75, 0x6d, 0x4c, 0xc0, 0xd9, 0x71, 0x59, 0x65, 0xa2, 0x20, 0x4b, 0x1f, 0x05, 0x6d, 0x7a, 0x08,
	0xf1, 0x87, 0xd0, 0xab, 0xb8, 0xdc, 0x65, 0x4b, 0x3e, 0x2f, 0xd8, 0x86, 0x37, 0xff, 0xd0, 0x59,
	0x93, 0xbb, 0x61, 0x1b, 0x8e, 0x9f, 0xc3, 0xb9, 0x28, 0x79, 0xed, 0xca, 0x1a, 0x6a, 0x19, 0xe8,
	0xad, 0x63, 0xd6, 0x60, 0x7d, 0xe8, 0x2c, 0x59, 0x9e, 0x73, 0x69, 0xfa, 0xed, 0xd2, 0x26, 0xba,
	0x37, 0xa3, 0xfd, 0x8f, 0x33, 0xb6, 0x4f, 0x67, 0xc4, 0xef, 0x42, 0xb7, 0x64, 0x92, 0x17, 0x4a,
	0x4b, 0x1d, 0x23, 0xb9, 0x75, 0x62, 0x62, 0xdc, 0x90, 0xf3, 0x1d, 0xcf, 0x89, 0x63, 0x46, 0xa9,
	0x03, 0x5d, 0xa6, 0x52, 0x4c, 0xaa, 0x39, 0x53, 0xc4, 0x35, 0x66, 0x70, 0x4c, 0x7c, 0xad, 0xf4,
	0x69, 0xab, 0xac, 0xc8, 0xaa, 0xd7, 0x5a, 0xeb, 0x1a, 0xcd, 0xad, 0x13, 0xd7, 0x0a, 0x7f, 0x0e,
	0x97, 0x15, 0xdb, 0x94, 0x79, 0x56, 0xa4, 0xf3, 0x52, 0x8a, 0x05, 0xd3, 0x6f, 0x5d, 0xed, 0x09,
	0xf8, 0x28, 0x68, 0xd1, 0x8b, 0x83, 0xf6, 0xc3, 0x1b, 0x49, 0x9b, 0x99, 0x17, 0x3b, 0x72, 0x51,
	0x9b, 0x99, 0x17, 0x3b, 0xfc, 0x15, 0x40, 0x5d, 0x5c, 0xfb, 0x8f, 0x5c, 0xfa, 0x28, 0x38, 0x1b,
	0x5d, 0x85, 0xf5, 0xd3, 0x0e, 0x0f, 0x4f, 0x3b, 0x9c, 0x1d, 0xcc, 0x49, 0xbb, 0x86, 0xd6, 0x31,
	0x7e, 0x01, 0xee, 0xe1, 0xc9, 0x93, 0xa7, 0x66, 0xe3, 0xb3, 0x07, 0x1b, 0x5f, 0x35, 0x00, 0x3d,
	0xa2, 0xf8, 0x05, 0x80, 0xe4, 0x2b, 0x2e, 0x79, 0xb1, 0xe4, 0x15, 0xe9, 0x1b, 0x8b, 0x3f, 0x7d,
	0xd4, 0x75, 0xf4, 0x04, 0xc4, 0xcf, 0xc1, 0x56, 0x2c, 0xad, 0xc8, 0x99, 0xd9, 0xf0, 0xf6, 0x83,
	0x8f, 0x06, 0x35, 0xb2, 0xc6, 0x72, 0x91, 0x56, 0xa4, 0xf7, 0x18, 0x16, 0x8b, 0x94, 0x1a, 0xf9,
	0x65, 0xff, 0xd7, 0xbb, 0x01, 0xfa, 0xed, 0x6e, 0x80, 0xfe, 0xbc, 0x1b, 0xa0, 0x9f, 0x5c, 0xd3,
	0x6f, 0xca, 0x8b, 0x45, 0xc7, 0xac, 0xbe, 0xf8, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x84, 0xa8, 0x26,
	0xca, 0x5a, 0x05, 0x00, 0x00,
}

func (m *Tag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSpan(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSpan(dAtA, i, uint64(m.Kind))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSpan(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Field) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Field) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSpan(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSpan(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Log) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Log) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSpan(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSpan(dAtA, i, uint64(m.Kind))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSpan(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSpan(dAtA, i, uint64(m.Timestamp))
	}
	if len(m.Fields) > 0 {
		for _, msg := range m.Fields {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintSpan(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SpanRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanRef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RefType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSpan(dAtA, i, uint64(m.RefType))
	}
	if m.TraceId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSpan(dAtA, i, uint64(m.TraceId))
	}
	if m.SpanId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSpan(dAtA, i, uint64(m.SpanId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Span) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Span) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServiceName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSpan(dAtA, i, uint64(len(m.ServiceName)))
		i += copy(dAtA[i:], m.ServiceName)
	}
	if len(m.OperationName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSpan(dAtA, i, uint64(len(m.OperationName)))
		i += copy(dAtA[i:], m.OperationName)
	}
	if len(m.Caller) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSpan(dAtA, i, uint64(len(m.Caller)))
		i += copy(dAtA[i:], m.Caller)
	}
	if m.TraceId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSpan(dAtA, i, uint64(m.TraceId))
	}
	if m.SpanId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSpan(dAtA, i, uint64(m.SpanId))
	}
	if m.ParentId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintSpan(dAtA, i, uint64(m.ParentId))
	}
	if m.Level != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintSpan(dAtA, i, uint64(m.Level))
	}
	if m.StartAt != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintSpan(dAtA, i, uint64(m.StartAt))
	}
	if m.FinishAt != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintSpan(dAtA, i, uint64(m.FinishAt))
	}
	if m.SamplingProbability != 0 {
		dAtA[i] = 0x55
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.SamplingProbability))))
		i += 4
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintSpan(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Logs) > 0 {
		for _, msg := range m.Logs {
			dAtA[i] = 0x62
			i++
			i = encodeVarintSpan(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Env) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSpan(dAtA, i, uint64(len(m.Env)))
		i += copy(dAtA[i:], m.Env)
	}
	if m.StartTime != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSpan(dAtA, i, uint64(m.StartTime.Size()))
		n1, err := m.StartTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Duration != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintSpan(dAtA, i, uint64(m.Duration.Size()))
		n2, err := m.Duration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.References) > 0 {
		for _, msg := range m.References {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintSpan(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Version != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintSpan(dAtA, i, uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintSpan(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Tag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovSpan(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovSpan(uint64(m.Kind))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovSpan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Field) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovSpan(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovSpan(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Log) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovSpan(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovSpan(uint64(m.Kind))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovSpan(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovSpan(uint64(m.Timestamp))
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovSpan(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpanRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RefType != 0 {
		n += 1 + sovSpan(uint64(m.RefType))
	}
	if m.TraceId != 0 {
		n += 1 + sovSpan(uint64(m.TraceId))
	}
	if m.SpanId != 0 {
		n += 1 + sovSpan(uint64(m.SpanId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Span) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovSpan(uint64(l))
	}
	l = len(m.OperationName)
	if l > 0 {
		n += 1 + l + sovSpan(uint64(l))
	}
	l = len(m.Caller)
	if l > 0 {
		n += 1 + l + sovSpan(uint64(l))
	}
	if m.TraceId != 0 {
		n += 1 + sovSpan(uint64(m.TraceId))
	}
	if m.SpanId != 0 {
		n += 1 + sovSpan(uint64(m.SpanId))
	}
	if m.ParentId != 0 {
		n += 1 + sovSpan(uint64(m.ParentId))
	}
	if m.Level != 0 {
		n += 1 + sovSpan(uint64(m.Level))
	}
	if m.StartAt != 0 {
		n += 1 + sovSpan(uint64(m.StartAt))
	}
	if m.FinishAt != 0 {
		n += 1 + sovSpan(uint64(m.FinishAt))
	}
	if m.SamplingProbability != 0 {
		n += 5
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovSpan(uint64(l))
		}
	}
	if len(m.Logs) > 0 {
		for _, e := range m.Logs {
			l = e.Size()
			n += 1 + l + sovSpan(uint64(l))
		}
	}
	l = len(m.Env)
	if l > 0 {
		n += 2 + l + sovSpan(uint64(l))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 2 + l + sovSpan(uint64(l))
	}
	if m.Duration != nil {
		l = m.Duration.Size()
		n += 2 + l + sovSpan(uint64(l))
	}
	if len(m.References) > 0 {
		for _, e := range m.References {
			l = e.Size()
			n += 2 + l + sovSpan(uint64(l))
		}
	}
	if m.Version != 0 {
		n += 2 + sovSpan(uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSpan(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSpan(x uint64) (n int) {
	return sovSpan(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Tag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= Tag_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSpan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSpan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Field) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Field: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Field: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSpan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSpan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Log) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Log: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Log: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= Log_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSpan
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSpan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, &Field{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefType", wireType)
			}
			m.RefType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefType |= SpanRef_RefType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceId", wireType)
			}
			m.TraceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TraceId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanId", wireType)
			}
			m.SpanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Span) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Span: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Span: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceId", wireType)
			}
			m.TraceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TraceId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanId", wireType)
			}
			m.SpanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			m.ParentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartAt", wireType)
			}
			m.StartAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishAt", wireType)
			}
			m.FinishAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinishAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamplingProbability", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SamplingProbability = float32(math.Float32frombits(v))
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logs = append(m.Logs, &Log{})
			if err := m.Logs[len(m.Logs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &timestamp.Timestamp{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Duration == nil {
				m.Duration = &duration.Duration{}
			}
			if err := m.Duration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.References = append(m.References, &SpanRef{})
			if err := m.References[len(m.References)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 99:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpan
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSpan(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSpan
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSpan
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthSpan
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSpan
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSpan(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthSpan
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSpan = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSpan   = fmt.Errorf("proto: integer overflow")
)
